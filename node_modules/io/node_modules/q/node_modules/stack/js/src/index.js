var CallSitePrototype, NODE_PATHS, NamedFunction, OS, SourceMap, Stack, StackFrame, WeakMap, basename, combine, define, extname, isNodeEnv, log, mm, prepareStackTrace, ref, stackTraceLimit;

require("lotus-require");

OS = require("os");

combine = require("combine");

mm = require("minimatch");

log = require("temp-log");

define = require("define");

WeakMap = require("weak-map");

NODE_PATHS = require("node-paths");

SourceMap = require("node-source-map");

NamedFunction = require("named-function");

ref = require("path"), basename = ref.basename, extname = ref.extname;

isNodeEnv = require("is-node-env");

Stack = module.exports = NamedFunction("Stack", function(error, options) {
  var frames, promise, promises, stack;
  if (!isNodeEnv) {
    return null;
  }
  if (Error.prepareStackTrace !== prepareStackTrace) {
    log(log.ln, error.stack, log.ln);
    log("ERROR: You forgot to call 'Stack.initialize()' after importing a module that changes 'Error.prepareStackTrace'.", log.ln, log.ln);
    process.exit(0);
  }
  if ((error != null) && error.constructor === Object) {
    options = error;
  } else {
    if (!((options != null) && options.constructor === Object)) {
      options = {};
    }
    if (error instanceof Error) {
      options.error = error;
    }
  }
  stack = {
    __proto__: Stack.prototype
  };
  combine(stack, Stack.defaults, options);
  if (options.error == null) {
    if (arguments.hasOwnProperty(1)) {
      throw TypeError("'error' must be an Error.");
    }
    stack.error = Error();
  }
  stack.error.stack;
  frames = Stack.cache.get(stack.error);
  if (frames == null) {
    return null;
  }
  frames = frames.map(function(frame) {
    return StackFrame(frame);
  });
  promises = [];
  promise = stack.error.promise;
  while (promise != null) {
    promises.push(promise);
    if ((promise.createdBy == null) && (promise.stack != null)) {
      promise.stack.forEach(function(frame) {
        frame.promise = promise;
        return frames.push(frame);
      });
    }
    promise = promise.createdIn;
  }
  if (promises.length > 0) {
    stack.promises = promises;
  }
  if (stack.exclude.length > 0) {
    frames = frames.filter(function(frame) {
      return !frame.matchesAny(stack.exclude);
    });
  }
  if (stack.filter instanceof Function) {
    frames = frames.filter(function(frame) {
      return stack.filter.apply(stack, arguments);
    });
  }
  if (!(stack.skip >= 0)) {
    stack.skip = 0;
  }
  if (!isFinite(stack.limit)) {
    delete stack.limit;
  } else if (stack.limit < 0) {
    stack.limit = stack.skip;
  } else {
    stack.limit += stack.skip;
  }
  if (stack.skip > 0 || (stack.limit != null)) {
    frames = frames.slice(stack.skip, stack.limit);
  }
  if (stack.map instanceof Function) {
    frames = frames.map(stack.map);
  }
  stack.frames = frames;
  return stack;
});

StackFrame = NamedFunction("StackFrame", function(frame) {
  if (!(this instanceof StackFrame)) {
    return new StackFrame(frame);
  }
  return define(this, function() {
    this.options = {
      configurable: false,
      enumerable: false,
      writable: false
    };
    return this({
      orig: {
        value: frame
      }
    });
  });
});

CallSitePrototype = ["getThis", "getTypeName", "getFunction", "getFunctionName", "getMethodName", "getFileName", "getLineNumber", "getColumnNumber", "getEvalOrigin", "getScriptNameOrSourceURL", "isToplevel", "isEval", "isNative", "isConstructor", "toString"];

stackTraceLimit = Infinity;

prepareStackTrace = function(error, stack) {
  stack = stack.map(function(frame) {
    return SourceMap.wrapCallSite(frame);
  });
  Stack.cache.set(error, stack);
  if (Stack.prepareStackTrace != null) {
    return Stack.prepareStackTrace(error, stack);
  }
  return error + stack.map(function(frame) {
    return OS.EOL + "  at " + frame.toString();
  });
};

define(function() {
  this.options = {
    configurable: false,
    writable: false
  };
  this(Stack, {
    Frame: StackFrame,
    isInitialized: {
      get: function() {
        return Error.prepareStackTrace === prepareStackTrace;
      }
    },
    initialize: function() {
      if (this.isInitialized) {
        return false;
      }
      Stack.prepareStackTrace = Error.prepareStackTrace;
      Error.stackTraceLimit = stackTraceLimit;
      Error.prepareStackTrace = prepareStackTrace;
      return true;
    }
  });
  this(StackFrame.prototype, {
    isNode: function() {
      var path;
      path = this.getFileName();
      return 0 <= NODE_PATHS.indexOf(basename(path, extname(path)));
    },
    isUserCreated: function() {
      return !(this.isEval() || this.isNative() || this.isNode());
    },
    matches: function(pattern) {
      var fileName;
      fileName = this.getFileName();
      if (fileName == null) {
        return false;
      }
      return mm(fileName, pattern);
    },
    matchesAny: function(patterns) {
      var fileName, i, len, pattern;
      fileName = this.getFileName();
      if (fileName == null) {
        return false;
      }
      for (i = 0, len = patterns.length; i < len; i++) {
        pattern = patterns[i];
        if (mm(fileName, pattern)) {
          return true;
        }
      }
      return false;
    }
  });
  CallSitePrototype.forEach((function(_this) {
    return function(key) {
      return _this(StackFrame.prototype, key, function() {
        return this.orig[key].apply(this.orig, arguments);
      });
    };
  })(this));
  this.writable = true;
  this(Stack, {
    cache: isNodeEnv ? WeakMap() : null,
    prepareStackTrace: Error.prepareStackTrace,
    defaults: {
      value: {
        skip: 0,
        limit: Infinity,
        exclude: []
      }
    }
  });
  if (isNodeEnv) {
    Error.stackTraceLimit = stackTraceLimit;
    return Error.prepareStackTrace = prepareStackTrace;
  }
});

//# sourceMappingURL=../../map/src/index.map
