// Generated by CoffeeScript 1.10.0
(function() {
  var _, _defineColor, _styler, capitalize, isNodeEnv, log, os, parseBool, process, temp,
    slice = [].slice;

  capitalize = require("capitalize");

  isNodeEnv = require("is-node-env");

  parseBool = require("parse-bool");

  process = require("process");

  os = require("os");

  _ = null;

  log = module.exports = function() {
    return log._.log.apply(null, arguments);
  };

  log.log = log;

  ["ln", "isVerbose", "isDebug"].forEach(function(key) {
    return Object.defineProperty(log, key, {
      enumerable: true,
      get: function() {
        return log._[key];
      }
    });
  });

  ["verbose", "debug", "warn", "error", "moat", "it", "format"].forEach(function(key) {
    return Object.defineProperty(log, key, {
      enumerable: true,
      value: function() {
        return log._[key].apply(log._, arguments);
      }
    });
  });

  _ = temp = {
    log: function() {
      var j, len, message, messages, type;
      messages = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      for (j = 0, len = messages.length; j < len; j++) {
        message = messages[j];
        if (message instanceof Array) {
          temp.log.apply(null, message);
        } else if (typeof message === "string") {
          if (isNodeEnv) {
            process.stdout.write(message);
          } else {
            console.log(message);
          }
        } else if (message instanceof Error) {
          temp.log(message.stack, log.ln);
          if (isNodeEnv) {
            process.exit(0);
          }
        } else {
          type = message != null ? message.constructor.name : "Void";
          throw Error("Invalid message type: " + type);
        }
      }
      return true;
    },
    ln: os.EOL,
    isVerbose: isNodeEnv && parseBool(process.env.VERBOSE) === true,
    isDebug: isNodeEnv && parseBool(process.env.DEBUG) === true,
    verbose: function() {
      var messages;
      messages = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (this.isVerbose) {
        return this.log.apply(null, messages);
      }
    },
    debug: function() {
      var messages;
      messages = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (this.isDebug) {
        return this.log.apply(null, messages);
      }
    },
    warn: function(message) {
      return this.log("WARNING: " + message);
    },
    error: function(error) {
      return this.log(error.message);
    },
    moat: function(width) {
      var i, j, ref;
      if (width <= 0) {
        return false;
      }
      for (i = j = 0, ref = width; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        this.log(this.ln);
      }
      return true;
    },
    it: function(message) {
      this.moat(0);
      this.log(message);
      return this.moat(0);
    },
    format: function(value, label) {
      if (label == null) {
        label = "";
      }
      return this.log(label + JSON.stringify(value));
    }
  };

  _styler = function() {
    var messages;
    messages = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return temp.log.apply(null, messages);
  };

  _defineColor = function(color) {
    Object.defineProperty(_styler, color, {
      enumerable: true,
      get: function() {
        return this;
      }
    });
    Object.defineProperty(temp, color, {
      enumerable: true,
      get: function() {
        return _styler;
      }
    });
    return Object.defineProperty(log, color, {
      enumerable: true,
      get: function() {
        return log._[color];
      }
    });
  };

  ["red", "blue", "green", "cyan", "white", "gray", "yellow", "pink", "black"].forEach(function(color) {
    _defineColor(color);
    return _defineColor("bg" + capitalize(color));
  });

  ["dim", "bold"].forEach(function(style) {
    return _defineColor(style);
  });

  Object.defineProperty(log, "_", {
    get: function() {
      return _;
    },
    set: function(newValue) {
      return _ = newValue;
    }
  });

}).call(this);
