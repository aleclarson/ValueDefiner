{
  "name": "q",
  "version": "1.0.0",
  "description": "Promises for Javascript",
  "homepage": "https://github.com/aleclarson/q",
  "author": {
    "name": "Alec Larson",
    "url": "https://github.com/aleclarson"
  },
  "keywords": [
    "q",
    "promise",
    "promises",
    "promises-a",
    "promises-aplus",
    "deferred",
    "future",
    "async",
    "flow control",
    "fluent",
    "browser",
    "node"
  ],
  "contributors": [
    {
      "name": "Alec Larson",
      "url": "https://github.com/aleclarson"
    }
  ],
  "license": {
    "type": "MIT"
  },
  "main": "q.js",
  "files": [
    "LICENSE",
    "q.js",
    "queue.js"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/aleclarson/q.git"
  },
  "dependencies": {
    "is-node-env": "github:aleclarson/is-node-env#1.0.0",
    "lotus-require": "github:aleclarson/lotus-require#1.0.0",
    "no-op": "^1.0.3",
    "parse-bool": "github:aleclarson/parse-bool#0.0.1",
    "stack": "github:aleclarson/stack#1.0.0",
    "temp-log": "github:aleclarson/temp-log#1.0.0"
  },
  "gitHead": "b532da69c36b908ff50c2840b7b7188019105eb1",
  "readme": "\n# q v1.0.0\n\nThis is a customized fork of the renowned [kriskowal/q](https://github.com/kriskowal/q) repo.\n\nIt's compatible with both NodeJS and React Native.\n\nEvery change I've made aims to do at least one of these things:\n\n&nbsp;&nbsp;&nbsp;&nbsp;\n**A.** provide new functionality\n\n&nbsp;&nbsp;&nbsp;&nbsp;\n**B.** reduce boilerplate\n\n&nbsp;&nbsp;&nbsp;&nbsp;\n**C.** provide valuable debugging information.\n\n&nbsp;\n\n## install\n\n```sh\nnpm install aleclarson/q#1.0.0\n```\n\n&nbsp;\n\n## changelog\n\nThis is a list of every addition/modification provided by this fork.\n\n&nbsp;\n\n#### promise.id\n\nA unique `Number` representing the order of when each `Promise` was made.\n\nThis will only be defined if this `Promise` was created while `Q.debug` was `true`.\n\n&nbsp;\n\n#### promise.state\n\nAn immutable `String` that represents the state of the `Promise`.\n\nPossible values include `\"pending\"`, `\"rejected\"`, and `\"fulfilled\"`.\n\nThis will only be defined if this `Promise` was created while `Q.debug` was `true`.\n\n&nbsp;\n\n#### promise.stack\n\nAn `Array` of `StackFrame` objects from [aleclarson/stack](https://github.com/aleclarson/stack).\n\nThis will only be defined if this `Promise` was created while `Q.debug` was `true`.\n\n&nbsp;\n\n#### promise.createdWith\n\nA mutable `String` that represents the method used to create this `Promise`.\n\n```CoffeeScript\n{ promise } = Q.defer()\n\npromise.createdWith         # \"Q.defer\"\n\npromise.then().createdWith  # \"promise.then\"\n```\n\nThis will only be defined if this `Promise` was created while `Q.debug` was `true`.\n\n&nbsp;\n\n#### promise.createdBy\n\nA mutable `String` that represents the method that made this `Promise` for internal use.\n\nIf this property equals `undefined`, this `Promise` was created outside of the `Q` library.\n\nThis property will only be defined if:\n\n- `Q.debug` was `true` when this `Promise` was created\n\n- A method in the `Q` library created it for internal use.\n\n```CoffeeScript\n{ promise } = Q.delay 100\n\npromise.createdBy           # undefined\n\npromise.previous.createdBy  # \"Q.delay\"\n```\n\n&nbsp;\n\n#### promise.createdIn\n\nThe `Promise` that this `Promise` was created inside of.\n\nThis will equal `undefined` when this `Promise` was not created inside another `Promise`.\n\nThis will only be defined if this `Promise` was created while `Q.debug` was `true`.\n\n&nbsp;\n\n#### promise.previous\n\nThe `Promise` that comes before this `Promise`.\n\nFor example, if this `Promise` handles rejections and `promise.previous` throws an error, this `Promise` will be the one that handles the thrown error.\n\nThis will equal `undefined` when this `Promise` is created with `Q.defer()` or `Q.makePromise()`.\n\n```CoffeeScript\ndeferred = Q.defer()\n\np1 = deferred.promise\n\np2 = p1.then()\n\np2.previous is p1        # true\n\np1.previous is undefined # true\n```\n\nThis will only be defined if this `Promise` was created while `Q.debug` was `true`.\n\n&nbsp;\n\n#### promise.result\n\nThe `Promise` resolved from the result of this `Promise`'s handlers.\n\nThis equals `undefined` if an `Error` is thrown.\n\n```CoffeeScript\ndeferred = Q.defer()\n\np1 = deferred.promise\n\np2 = p1.then()\n\np2.previous is p1        # true\n\np1.previous is undefined # true\n```\n\nThis will only be defined if this `Promise` was created while `Q.debug` was `true`.\n\n&nbsp;\n\n#### promise.then(deferred)\n\n```CoffeeScript\n# What once was...\npromise.then deferred.resolve, deferred.reject\n\n# Now as easy as...\npromise.then deferred\n```\n\n&nbsp;\n\n#### promise.always(callback)\n\nThis replaces (and is identical to) `promise.fin()` and `promise.finally()`.\n\n&nbsp;\n\n#### error.promise\n\nThe first `Promise` inside which this `Error` was thrown.\n\nObviously, this will equal `undefined` if the `Error` was never thrown within a `Promise`'s handlers.\n\n```CoffeeScript\ndeferred = Q.defer()\n\npromise = deferred.promise.then ->\n  throw Error()\n\npromise.fail (error) ->\n  error.promise is promise # true\n```\n\n&nbsp;\n\n#### Q.debug\n\nWhile this is `true`, new `Promise` instances will expose valuable debugging information.\n\nDefaults to `false`.\n\n&nbsp;\n\n#### Q.verbose\n\nWhile this is `true` and `Q.debug` is `true`, more debugging messages will be printed.\n\nDefaults to `false`.\n\n&nbsp;\n\n#### Q.cache\n\nWhile `Q.debug === true` and `Q.cache` has a value, all `Promise`s created will be stored using `promise.id` as the key.\n\n**NOTE:** You may face memory problems if you leave `Q.cache` set for the whole duration of the program (especially long-running ones).\n\n&nbsp;\n\n#### Q.activePromise\n\nThe last `Promise` in `Q.activePromises`.\n\nThis will only be defined if `Q.debug` is `true`.\n\n&nbsp;\n\n#### Q.activePromises\n\nAn array of `Promise` instances that are currently active.\n\nThis will only be defined if `Q.debug` is `true`.\n\n&nbsp;\n\n#### Q.onRejection\n\nYou can set this to a `Function` if you want to know when a `Promise` is rejected.\n\nUnlike `Q.onError`, setting `Q.onRejection` does **not** disable any built-in handling.\n\nThis is only called when `Q.debug` is `true`.\n\n```CoffeeScript\nQ.onRejection = (promise, error) ->\n  # Do some debugging...\n```\n\nThe `promise` argument is the `Promise` that was rejected.\n\nThe `error` argument is the `Error` that was thrown.\n\n&nbsp;\n\n#### Q.onBecome\n\nYou can set this to a `Function` if you want to be notified every time a scheduled `Promise` is starting.\n\nThis is only called when `Q.debug` is `true`.\n\n```CoffeeScript\nQ.onBecome = (promise, previous) ->\n  # Do some debugging...\n```\n\nThe `promise` argument is the `Promise` that is about to start.\n\nThe `previous` argument is the `Promise` that needed to resolve before `promise` could start.\n\n&nbsp;\n\n#### Q.onError\n\nThis is a simple rename from `Q.onerror` to `Q.onError`.\n\nYou can set this to a `Function` if you want to override the built-in error handling.\n\nCurrently, the built-in error handling automatically forwards thrown `Error` instances to the next `Promise` down the chain that can handle rejections.\n\n```CoffeeScript\nQ.onError = (error) ->\n  # Do some debugging...\n```\n\n&nbsp;\n\n## Deprecations\n\n- Removed `promise.catch()`. Use `promise.fail()` exclusively.\n\n- Removed `promise.allResolved()`. Use `promise.allSettled()` exclusively.\n\n&nbsp;\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/aleclarson/q/issues"
  },
  "_id": "q@1.0.0",
  "_shasum": "014c11db2dd96857546af4200fb68a1218bc7ba9",
  "_from": "aleclarson/q#1.0.0",
  "_resolved": "git://github.com/aleclarson/q.git#b532da69c36b908ff50c2840b7b7188019105eb1"
}
