
require "lotus-require"

OS = require "os"
combine = require "combine"
mm = require "minimatch"
log = require "temp-log"
define = require "define"
WeakMap = require "weak-map"
NODE_PATHS = require "node-paths"
SourceMap = require "node-source-map"
NamedFunction = require "named-function"
{ basename, extname } = require "path"
isNodeEnv = require "is-node-env"

Stack = module.exports = NamedFunction "Stack", (error, options) ->

  return null if !isNodeEnv

  if Error.prepareStackTrace isnt prepareStackTrace
    log log.ln, error.stack, log.ln
    log "ERROR: You forgot to call 'Stack.initialize()' after importing a module that changes 'Error.prepareStackTrace'.", log.ln, log.ln
    process.exit 0

  if error? and error.constructor is Object
    options = error

  else
    options = {} unless options? and options.constructor is Object
    options.error = error if error instanceof Error

  stack = __proto__: Stack.prototype

  combine stack, Stack.defaults, options

  if !options.error?
    if arguments.hasOwnProperty 1 then throw TypeError "'error' must be an Error."
    stack.error = Error()

  stack.error.stack

  frames = Stack.cache.get stack.error

  return null if !frames?

  # Remove 'Error()' and 'getStack()' stack frames.
  # frames = frames.slice 2 if !options.error?

  frames = frames.map (frame) -> StackFrame frame

  promises = []

  { promise } = stack.error

  while promise?

    promises.push promise

    if !promise.createdBy? and promise.stack?

        promise.stack.forEach (frame) ->
          frame.promise = promise
          frames.push frame

    promise = promise.createdIn

  if promises.length > 0
    stack.promises = promises

  # Apply 'options.exclude'.
  if stack.exclude.length > 0
    frames = frames.filter (frame) ->
      not frame.matchesAny stack.exclude

  # Apply 'options.filter'.
  if stack.filter instanceof Function
    frames = frames.filter (frame) ->
      stack.filter.apply stack, arguments

  stack.skip = 0 unless stack.skip >= 0

  unless isFinite stack.limit
    delete stack.limit

  else if stack.limit < 0
    stack.limit = stack.skip

  else
    stack.limit += stack.skip

  # Apply 'options.skip' and 'options.limit'.
  if stack.skip > 0 or stack.limit?
    frames = frames.slice stack.skip, stack.limit

  # Apply 'options.map'.
  if stack.map instanceof Function
    frames = frames.map stack.map

  stack.frames = frames

  stack

StackFrame = NamedFunction "StackFrame", (frame) ->
  return new StackFrame frame unless this instanceof StackFrame
  define this, ->
    @options = configurable: no, enumerable: no, writable: no
    @ orig: value: frame

# From: https://code.google.com/p/v8-wiki/wiki/JavaScriptStackTraceApi
CallSitePrototype = [
  "getThis",
  "getTypeName",
  "getFunction",
  "getFunctionName"
  "getMethodName"
  "getFileName"
  "getLineNumber"
  "getColumnNumber"
  "getEvalOrigin"
  "getScriptNameOrSourceURL"
  "isToplevel"
  "isEval"
  "isNative"
  "isConstructor"
  "toString"
]

stackTraceLimit = Infinity

prepareStackTrace = (error, stack) ->

  stack = stack.map (frame) -> SourceMap.wrapCallSite frame

  Stack.cache.set error, stack

  return Stack.prepareStackTrace error, stack if Stack.prepareStackTrace?

  error + stack.map (frame) -> OS.EOL + "  at " + frame.toString()

define ->

  @options = configurable: no, writable: no

  @ Stack,

    Frame: StackFrame

    isInitialized:
      get: -> Error.prepareStackTrace is prepareStackTrace

    initialize: ->
      return no if @isInitialized
      Stack.prepareStackTrace = Error.prepareStackTrace
      Error.stackTraceLimit = stackTraceLimit
      Error.prepareStackTrace = prepareStackTrace
      yes

  @ StackFrame.prototype,

    isNode: ->
      path = @getFileName()
      0 <= NODE_PATHS.indexOf basename path, extname path

    isUserCreated: ->
      not ( @isEval() or @isNative() or @isNode() )

    matches: (pattern) ->
      fileName = @getFileName()
      return no if !fileName?
      mm fileName, pattern

    matchesAny: (patterns) ->
      fileName = @getFileName()
      return no if !fileName?
      return yes for pattern in patterns when mm fileName, pattern
      no

  CallSitePrototype.forEach (key) =>
    @ StackFrame.prototype, key, ->
      @orig[key].apply @orig, arguments

  @writable = yes

  @ Stack,

    cache: if isNodeEnv then WeakMap() else null

    prepareStackTrace: Error.prepareStackTrace

    defaults: value:
      skip: 0
      limit: Infinity
      exclude: []

  if isNodeEnv
    # Set these without 'define' so the internal setters are not yet overridden.
    Error.stackTraceLimit = stackTraceLimit
    Error.prepareStackTrace = prepareStackTrace
