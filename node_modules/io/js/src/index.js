var addons, define, isKind, isType, q, ref;

require("lotus-require");

ref = require("type-utils"), isType = ref.isType, isKind = ref.isKind;

define = require("define");

q = require("q");

addons = [require("./fs"), require("./iter")];

define(function() {
  var addon, i, j, key, len, len1, ref1;
  this.options = {
    frozen: true
  };
  this(exports, {
    sync: {},
    async: {}
  });
  for (i = 0, len = addons.length; i < len; i++) {
    addon = addons[i];
    ref1 = ["sync", "async"];
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      key = ref1[j];
      if (addon === null) {
        continue;
      }
      this(exports[key], addon[key]);
    }
  }
  return this(exports.async, {
    "try": q["try"],
    when: q.when,
    all: q.all,
    promise: q.promise,
    promised: function(func) {
      return function() {
        var args, self;
        self = this;
        args = arguments;
        return q["try"](function() {
          return func.apply(self, args);
        });
      };
    },
    loop: function(timeout, looper) {
      var deferred, done, isDone, loops, result, tick;
      if (!arguments.hasOwnProperty(1)) {
        looper = timeout;
        timeout = null;
      }
      deferred = q.defer();
      loops = 0;
      isDone = false;
      result = void 0;
      done = function() {
        isDone = true;
        return result = arguments[0];
      };
      tick = function() {
        var error, tickPromise;
        try {
          tickPromise = q(looper(done, loops++));
        } catch (_error) {
          error = _error;
          return deferred.reject(error);
        }
        return tickPromise.always(function() {
          if (isDone) {
            return deferred.resolve(result);
          } else {
            return tick();
          }
        });
      };
      q.nextTick(tick);
      if (typeof timeout === "number") {
        return q.timeout(deferred.promise, timeout);
      }
      return deferred.promise;
    },
    "throw": function(error, info) {
      var value;
      if (!isKind(error, Error)) {
        if (arguments.hasOwnProperty(1)) {
          error = Error();
        } else {
          info = error;
          error = info.error || Error();
        }
      }
      if (!isType(info, Object)) {
        info = {};
      }
      error.fatal = isType(info.fatal, Boolean) ? info.fatal : true;
      if (isType(info.code, String)) {
        error.code = info.code;
      }
      if (isKind(info.format, Function) || isType(info.format, Object)) {
        error.format = info.format;
      }
      for (key in info) {
        value = info[key];
        if (!error.hasOwnProperty(key)) {
          error[key] = value;
        }
      }
      throw error;
    },
    "catch": function(error, caught) {
      if (error.fatal === false) {
        return false;
      }
      if (!isKind(caught, Function)) {
        throw error;
      }
      return caught(error);
    },
    delay: q.delay,
    timeout: q.timeout,
    nextTick: q.nextTick,
    resolve: q.resolve,
    fulfill: q.fulfill,
    reject: q.reject,
    defer: q.defer,
    Promise: q.makePromise
  });
});

//# sourceMappingURL=../../map/src/index.map
